[{"id":0,"href":"/docs/download-m3u8/","title":"How to download .m3u8","section":"Docs","content":"ffmpeg -i \u0026#34;url/list.m3u8\u0026#34; -map p:1 -c copy -bsf:a aac_adtstoasc \u0026#34;/home/file/video.mp4\u0026#34; với -map p:1 để chọn trong danh sách, bắt đầu từ 0\n#EXTM3U #EXT-X-VERSION:3 #EXT-X-STREAM-INF:BANDWIDTH=400000,NAME=\u0026#34;low\u0026#34; size1.m3u8 #EXT-X-STREAM-INF:BANDWIDTH=800000,NAME=\u0026#34;med\u0026#34; size2.m3u8 #EXT-X-STREAM-INF:BANDWIDTH=1900000,NAME=\u0026#34;best\u0026#34; size3.m3u8 chuyển từ ts sang mp4\n-bsf:a aac_adtstoasc "},{"id":1,"href":"/docs/java-thread/","title":"Java Thread","section":"Docs","content":"I. Thread #  Thread 71 sách java network programming  1. Synchronization #  A thread is like a borrower at a library; the thread borrows from a central pool of re‐ sources. Threads make programs more efficient by sharing memory, file handles, sockets, and other resources. As long as two threads don’t want to use the same resource at the same time, a multithreaded program is much more efficient than the multiprocess alternative, in which each process has to keep its own copy of every resource. The downside of a multithreaded program is that if two threads want the same resource at the same time, one of them will have to wait for the other to finish. If one of them doesn’t wait, the resource may get corrupted\nThread như người mượn ở thư viện, thread mượn từ central pool resource. Thread làm cho chương trình hiệu quả bởi chia sẻ bộ nhớ, xử lý file, socket, \u0026hellip;. Nếu 2 thread ko sử dụng cùng 1 resource cùng 1 lúc, thì chương trình multithreaded hiệu quả hơn so với việc lựa chọn multiprocess. Hai thread không sử dụng cùng 1 resource at the same time.\nNhược điểm của chương trình multithreaded là nếu 2 thread muốn sử dụng cùng resource cùng 1 thời điểm thì 1 trong 2 phải đợi cho thằng kia làm xong. Nếu 1 trong 2 thằng ko thể đợi, resouce có thể bị hỏng\n2. Đặt vấn đề : #  Chạy 4 thread cho chương trình sau. Nó ra output ko mong muốn như hình\nThe reason this mix-up occurs is that System.out is shared between the four different threads. When one thread starts writing to the console through several System.out.print() statements, it may not finish all its writes before another thread breaks in and starts writing its output.\nYou need a way to assign exclusive access to a shared resource to one thread for a specific series of statements. In this example, that shared resource is System.out, and the statements that need exclusive access are\nLý do System.out được chia sẻ cho 4 thread. Khi 1 thread chạy ghi vào console, nó có thể không hoàn thành trước khi 1 thread ngắt và bắt đầu khi vào console.\nBạn cần 1 cách để gán exclusive access vào resource được chia sẻ cho 1 thread. Trong ví dụ, là shared resource System.out, và cần gán exclusive access vào câu lệnh này\n3. Synchronized Blocks #  Wrap them in a synchronized block that synchronizes on the System.out object, like this:\nsynchronized (System.out) {   System.out.print(input + \u0026#34;: \u0026#34;);  System.out.print(DatatypeConverter.printHexBinary(digest));  System.out.println(); } Once one thread starts printing out the values, all other threads will have to stop and wait for it to finish before they can print out their values.\nSynchronization forces all code that synchronizes on the same object to run in series, never in parallel. For instance, if some other code in a different class and different thread also happened to synchronize on System.out, it too would not be able to run in parallel with this block. However, other code that synchronizes on a different object or doesn’t synchronize at all can still run in parallel with this code.\nSynchronization buộc tất cả các code synchronizes trên cùng những object giống nhau run theo dãy, nerver in parallel. Ví dụ, nếu một mã khác trong 1 class khác và khác thread tình cờ synchronize trên đối tượng static class PrintStream, System.out, nó sẽ không thể chạy parallel với khối lệnh này. Tuy nhiên, code khác synchronizes trên đối tượng khác hoặc không synchronize đồng thời vẫn có thể chạy được đoạn code này. Synchronize chỉ có thể ngăn các luồng khác đồng bộ hóa trên cùng đối tượng giống nhau sử dụng tài nguyên được chia sẻ.\nThe key is the resources they share, not what classes they are. Synchronization becomes an issue only when two threads both possess references to the same object. In the previous example, the problem was that several threads had access to the same PrintStream object, System.out. In this case, it was a static class variable that led to the conflict. However, instance variables can also have problems\n4. Synchronized Methods #  You can synchronize an entire method on the current object (the this reference) by adding the synchronized modifier to the method declaration\n lưu ý từ khóa synchronized ở hàm writeEntry\n import java.io.*; import java.util.*;  public class LogFile {   private Writer out;   public LogFile(File f) throws IOException {   FileWriter fw = new FileWriter(f);  this.out = new BufferedWriter(fw);  }   public synchronized void writeEntry(String message) throws IOException {  Date d = new Date();  out.write(d.toString());  out.write(\u0026#39;\\t\u0026#39;);  out.write(message);  out.write(\u0026#34;\\r\\n\u0026#34;);  }   public void close() throws IOException {  out.flush();  out.close();  } } Simply adding the synchronized modifier to all methods is not a catchall solution for synchronization problems. For one thing, it exacts a severe performance penalty in many VMs (though more recent VMs have improved greatly in this respect), potentially slowing down your code by a factor of three or more. Second, it dramatically increases the chances of deadlock. Third, and most importantly, it’s not always the object itself you need to protect from simultaneous modification or access, and synchronizing on the instance of the method’s class may not protect the object you really need to protect.\nBằng cách thêm từ khóa synchronized vào tất cả các methods ko phải là giải pháp cho vấn đề đồng bộ hóa. Thứ nhất, gây chậm hiệu suất VMs. Thứ hai, tăng nguy cơ gây deadlock. Thứ ba, quan trọng nhất, không phải lúc nào bản thân đối tượng bạn cũng cần bảo vệ khỏi sự sửa đổi hoặc truy cập đồng thời, và đồng bộ hóa trên instance của method class có thể không bảo vệ được đối tượng bạn thực sự cần bảo vệ.\nFor instance, in this example, what you’re really trying to prevent is two threads simultaneously writing onto out. If some other class had a reference to out completely unrelated to the LogFile, this attempt would fail. However, in this example, synchronizing on the LogFile object is sufficient because out is a private instance variable. Because you never expose a reference to this object, there’s no way for any other object to invoke its methods except through the LogFile class. Therefore, synchronizing on the Log File object has the same effect as synchronizing on out.\nTrong ví dụ trên, bạn thực sự cần ngăn 2 thread đồng thời ghi vào đối tượng out. Nếu 1 class khác có tham chiếu của out, thì sẽ thất bại trong việc đồng bộ hóa. Tuy nhiên, trong ví dụ, đồng bộ hóa đối tượng LogFile là đủ vì out là thuộc tính private. Vì bạn ko public tham chiếu đối tượng này, nên ko có cách nào để đối tượng khác có thể gọi phương thức này ngoại trừ thông qua lớp LogFile. Do đó, đồng bộ trên đối tượng LogFile có tác dụng tương tự như đồng bộ trên đối tượng out.\nII. Stream #  1. InputStream \u0026amp; OutputStream #  InputStream and OutputStream are both abstract classes, so you cannot\ncreate instances. The InputStream and OutputStream subclasses represent byte streams and provide the means of reading and writing binary data as a series of bytes.\n2. Buﬀered Input Streams #  The BufferedInputStream class defines an input stream that is buffered in memory and thus makes read operations on the stream more efficient. You create a BufferedInputStream object from another input stream\nBufferedInputStream keyboard = new BufferedInputStream(System.in);\n3. Stream Readers and Writers #  Stream readers and writers are objects that can read and write byte streams as character streams. Reader and Writer are both abstract classes\n4. Accessing Files and Directories #  A FileSystem object encapsulates the file storage system on your computer. The FileSystem class has no public constructors so you need another way to create such an object. You can obtain the FileSystem object that encapsulates the storage system on your machine by calling the getDefault() method.\nFileSystem fileSystem = FileSystems.getDefault(); A java.nio.file.Path object encapsulates a system-dependent file path to a file or directory. Path is an interface type so you cannot create Path objects directly. You call the getPath() method for a FileSystem object to obtain a Path object encapsulating a given file or directory path:\nPath path = fileSystem.getPath(“C:/Program Files (x86)/Java/jdk1.7.0/src/java/nio/file”); You can also create a Path object using the static get() method that is defined in the java.nio.file.Paths class. The Paths class has two versions of the get() method. One creates\na Path object from a string, the other creates a Path object from a java.net.URI object.\nPath myPath = Paths.get(“C:/Program Files (x86)/Java/jdk1.7.0/src/java/nio/file”); System Properties\n Lấy vị trí thư mục hiện tại  String currentDir = System.getProperty(“user.dir”);  Lấy dấu Slash / hay back slash \\ phân cách trong đường dẫn  String currentDir = System.getProperty(“file.separator”);  Lấy user home  String currentDir = System.getProperty(“user.home”); Đường dẫn tương đối\nIf the current directory is C:\\Projects\\Test, the myFile object references the path to the file C:\\Projects\\Test\\dir\\output.txt\nPath myFile = Paths.get(“dir”, “output.txt”);  Path myFile = Paths.get(“output.txt”); Tạo thư mục\nPath path =Paths.get(“newDir”);  try {  Files.createDirectory(path); //import từ package java.nio.file.Files } catch(IOException e) {  e.printStackTrace(System.err); } Tạo tập tin\nTo create a new empty file you can call the static createFile() method.\n5. Writing Files #  The java.nio.file.Files class provides three ways for you to access a file to write it:\nThe newOutputStream() method opens or creates a file specified by a Path object. The method returns a reference to an unbuffered OutputStream object encapsulating the file. If you wrap this OutputStream object in a BufferedOutputStream object, you are able to use the write() method for the buffered stream object to write binary data to the file efficiently.\nThe newBufferedWriter() method opens or creates a file specified by a Path object for writing in text mode. The BufferedWriter object that the method returns provides an efficient way to write textual data to a file.\nBufferedOutputStream fileOut = new BufferedOutputStream(Files.newOutputStream(path)); 6. Reading Files #  You have three ways for reading files, all provided by static methods in the java.nio.file.Files:\n  The newInputStream() method returns an InputStream object, which you can use to read a binary file.\n  The newBufferedReader() method returns a BufferedReader object, which you can use to read a file containing character data.\n  "}]